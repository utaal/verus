(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :rlimit 0)

;; Prelude

;; AIR prelude

(declare-sort FuelId)
(declare-sort Fuel)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(axiom (=>
  fuel_defaults
  (forall ((id FuelId)) (!
    (= (fuel_bool id) (fuel_bool_default id))
    :pattern ((fuel_bool id))
))))
(declare-sort Poly)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (Fun) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) Fun)
(declare-sort Type)
(declare-const BOOL Type)
(declare-const FUN Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(axiom (forall ((x Poly) (t Type)) (!
   (and
    (has_type (as_type x t) t)
    (=>
     (has_type x t)
     (= x (as_type x t))
   ))
   :pattern ((as_type x t))
)))
(axiom (forall ((x Bool)) (!
   (= x (%B (B x)))
   :pattern ((B x))
)))
(axiom (forall ((x Fun)) (!
   (= x (%F (F x)))
   :pattern ((F x))
)))
(axiom (forall ((x Int)) (!
   (= x (%I (I x)))
   :pattern ((I x))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x BOOL)
    (= x (B (%B x)))
   )
   :pattern ((has_type x BOOL))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x FUN)
    (= x (F (%F x)))
   )
   :pattern ((has_type x FUN))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x INT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x INT))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-const SZ Int)
(axiom (or
  (= SZ 32)
  (= SZ 64)
))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(axiom (= (uHi 8) 256))
(axiom (= (uHi 16) 65536))
(axiom (= (uHi 32) 4294967296))
(axiom (= (uHi 64) 18446744073709551616))
(axiom (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(axiom (= (iLo 8) (- 128)))
(axiom (= (iLo 16) (- 32768)))
(axiom (= (iLo 32) (- 2147483648)))
(axiom (= (iLo 64) (- 9223372036854775808)))
(axiom (= (iLo 128) (- 170141183460469231731687303715884105728)))
(axiom (= (iHi 8) 128))
(axiom (= (iHi 16) 32768))
(axiom (= (iHi 32) 2147483648))
(axiom (= (iHi 64) 9223372036854775808))
(axiom (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(axiom (forall ((i Int)) (!
   (and
    (<= 0 (nClip i))
    (=>
     (<= 0 i)
     (= i (nClip i))
   ))
   :pattern ((nClip i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= 0 (uClip bits i))
    (< (uClip bits i) (uHi bits))
    (=>
     (and
      (<= 0 i)
      (< i (uHi bits))
     )
     (= i (uClip bits i))
   ))
   :pattern ((uClip bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= (iLo bits) (iClip bits i))
    (< (iClip bits i) (iHi bits))
    (=>
     (and
      (<= (iLo bits) i)
      (< i (iHi bits))
     )
     (= i (iClip bits i))
   ))
   :pattern ((iClip bits i))
)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(axiom (forall ((bits Int) (i Int)) (!
   (= (uInv bits i) (and
     (<= 0 i)
     (< i (uHi bits))
   ))
   :pattern ((uInv bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (= (iInv bits i) (and
     (<= (iLo bits) i)
     (< i (iHi bits))
   ))
   :pattern ((iInv bits i))
)))
(axiom (forall ((x Int)) (!
   (has_type (I x) INT)
   :pattern ((has_type (I x) INT))
)))
(axiom (forall ((x Int)) (!
   (=>
    (<= 0 x)
    (has_type (I x) NAT)
   )
   :pattern ((has_type (I x) NAT))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (uInv bits x)
    (has_type (I x) (UINT bits))
   )
   :pattern ((has_type (I x) (UINT bits)))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (iInv bits x)
    (has_type (I x) (SINT bits))
   )
   :pattern ((has_type (I x) (SINT bits)))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (<= 0 (%I x))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (uInv bits (%I x))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (iInv bits (%I x))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-fun check_decrease_int.? (Int Int Bool) Bool)
(axiom (forall ((cur Int) (prev Int) (otherwise Bool)) (!
   (= (check_decrease_int.? cur prev otherwise) (or
     (and
      (<= 0 cur)
      (< cur prev)
     )
     (and
      (= cur prev)
      otherwise
   )))
   :pattern ((check_decrease_int.? cur prev otherwise))
)))
(declare-fun height.? (Poly) Int)
(axiom (forall ((x Poly)) (!
   (<= 0 (height.? x))
   :pattern ((height.? x))
)))

;; MODULE ''
(push)

 ;; Fuel
 (axiom true)

 ;; Datatypes
 (declare-datatypes () ((tuple%0. (tuple%0./tuple%0))))
 (declare-const TYPE%tuple%0. Type)
 (declare-fun Poly%tuple%0. (tuple%0.) Poly)
 (declare-fun %Poly%tuple%0. (Poly) tuple%0.)
 (axiom (forall ((x@ tuple%0.)) (!
    (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
    :pattern ((Poly%tuple%0. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%tuple%0.)
     (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
    )
    :pattern ((has_type x@ TYPE%tuple%0.))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
    :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
 )))

 ;; Function-Axioms crate::add1
 (declare-fun ens%add1. (Int Int) Bool)
 (axiom (forall ((pre%a@ Int) (a@ Int)) (!
    (= (ens%add1. pre%a@ a@) (and
      (uInv 64 a@)
      (= a@ (uClip 64 (+ pre%a@ 1)))
    ))
    :pattern ((ens%add1. pre%a@ a@))
 )))

 ;; Function-Def crate::add1
 (check-valid
  (declare-var a@ Int)
  (axiom fuel_defaults)
  (axiom (uInv 64 a@))
  (block
   (snapshot snapshot%pre)
   (assign a@ (uClip 64 (+ a@ 1)))
   (assert
    ("test.rs:8:13: 8:34 (#0)")
    (= a@ (uClip 64 (+ (old snapshot%pre a@) 1)))
 )))
(pop)
