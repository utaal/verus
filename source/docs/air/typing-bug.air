(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :rlimit 0)

;; Prelude

;; AIR prelude

(declare-sort FuelId)
(declare-sort Fuel)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(axiom (=>
  fuel_defaults
  (forall ((id FuelId)) (!
    (= (fuel_bool id) (fuel_bool_default id))
    :pattern ((fuel_bool id))
))))
(declare-sort Poly)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-sort Type)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (Fun) Fun)
(axiom (has_type (B true) BOOL))
(axiom (has_type (B false) BOOL))
(axiom (forall ((x Poly) (t Type)) (!
   (and
    (has_type (as_type x t) t)
    (=>
     (has_type x t)
     (= x (as_type x t))
   ))
   :pattern ((as_type x t))
)))
(axiom (forall ((x Fun)) (!
   (= (mk_fun x) x)
   :pattern ((mk_fun x))
)))
(axiom (forall ((x Bool)) (!
   (= x (%B (B x)))
   :pattern ((B x))
)))
(axiom (forall ((x Int)) (!
   (= x (%I (I x)))
   :pattern ((I x))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x BOOL)
    (= x (B (%B x)))
   )
   :pattern ((has_type x BOOL))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x INT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x INT))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-const SZ Int)
(axiom (or
  (= SZ 32)
  (= SZ 64)
))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(axiom (= (uHi 8) 256))
(axiom (= (uHi 16) 65536))
(axiom (= (uHi 32) 4294967296))
(axiom (= (uHi 64) 18446744073709551616))
(axiom (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(axiom (= (iLo 8) (- 128)))
(axiom (= (iLo 16) (- 32768)))
(axiom (= (iLo 32) (- 2147483648)))
(axiom (= (iLo 64) (- 9223372036854775808)))
(axiom (= (iLo 128) (- 170141183460469231731687303715884105728)))
(axiom (= (iHi 8) 128))
(axiom (= (iHi 16) 32768))
(axiom (= (iHi 32) 2147483648))
(axiom (= (iHi 64) 9223372036854775808))
(axiom (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(axiom (forall ((i Int)) (!
   (and
    (<= 0 (nClip i))
    (=>
     (<= 0 i)
     (= i (nClip i))
   ))
   :pattern ((nClip i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= 0 (uClip bits i))
    (< (uClip bits i) (uHi bits))
    (=>
     (and
      (<= 0 i)
      (< i (uHi bits))
     )
     (= i (uClip bits i))
   ))
   :pattern ((uClip bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= (iLo bits) (iClip bits i))
    (< (iClip bits i) (iHi bits))
    (=>
     (and
      (<= (iLo bits) i)
      (< i (iHi bits))
     )
     (= i (iClip bits i))
   ))
   :pattern ((iClip bits i))
)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(axiom (forall ((bits Int) (i Int)) (!
   (= (uInv bits i) (and
     (<= 0 i)
     (< i (uHi bits))
   ))
   :pattern ((uInv bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (= (iInv bits i) (and
     (<= (iLo bits) i)
     (< i (iHi bits))
   ))
   :pattern ((iInv bits i))
)))
(axiom (forall ((x Int)) (!
   (has_type (I x) INT)
   :pattern ((has_type (I x) INT))
)))
(axiom (forall ((x Int)) (!
   (=>
    (<= 0 x)
    (has_type (I x) NAT)
   )
   :pattern ((has_type (I x) NAT))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (uInv bits x)
    (has_type (I x) (UINT bits))
   )
   :pattern ((has_type (I x) (UINT bits)))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (iInv bits x)
    (has_type (I x) (SINT bits))
   )
   :pattern ((has_type (I x) (SINT bits)))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (<= 0 (%I x))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (uInv bits (%I x))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (iInv bits (%I x))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-fun check_decrease_int.? (Int Int Bool) Bool)
(axiom (forall ((cur Int) (prev Int) (otherwise Bool)) (!
   (= (check_decrease_int.? cur prev otherwise) (or
     (and
      (<= 0 cur)
      (< cur prev)
     )
     (and
      (= cur prev)
      otherwise
   )))
   :pattern ((check_decrease_int.? cur prev otherwise))
)))
(declare-fun height.? (Poly) Int)
(axiom (forall ((x Poly)) (!
   (<= 0 (height.? x))
   :pattern ((height.? x))
)))
(declare-fun uintxor (Int Int) Int)
(declare-fun uintand (Int Int) Int)
(declare-fun uintor (Int Int) Int)
(declare-fun uintshr (Int Int) Int)
(declare-fun uintshl (Int Int) Int)
(declare-fun uintnot (Int) Int)

;; MODULE ''
(push)

 ;; Fuel
 (axiom true)

 ;; Datatypes
 (declare-datatypes () ((S. (S./S (S./S/?a Poly) (S./S/?b Bool))) (tuple%0. (tuple%0./tuple%0))))
 (declare-fun S./S/a (S.) Poly)
 (declare-fun S./S/b (S.) Bool)
 (declare-fun TYPE%pervasive.invariants.Invariant. (Type) Type)
 (declare-fun TYPE%pervasive.invariants.LocalInvariant. (Type) Type)
 (declare-fun TYPE%S. (Type) Type)
 (declare-const TYPE%tuple%0. Type)
 (declare-fun Poly%S. (S.) Poly)
 (declare-fun %Poly%S. (Poly) S.)
 (declare-fun Poly%tuple%0. (tuple%0.) Poly)
 (declare-fun %Poly%tuple%0. (Poly) tuple%0.)
 (axiom (forall ((x@ S.)) (!
    (= x@ (%Poly%S. (Poly%S. x@)))
    :pattern ((Poly%S. x@))
 )))
 (axiom (forall ((A& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%S. A&))
     (= x@ (Poly%S. (%Poly%S. x@)))
    )
    :pattern ((has_type x@ (TYPE%S. A&)))
 )))
 (axiom (forall ((A& Type) (a@ Poly) (b@ Bool)) (!
    (=>
     (has_type a@ A&)
     (has_type (Poly%S. (S./S a@ b@)) (TYPE%S. A&))
    )
    :pattern ((has_type (Poly%S. (S./S a@ b@)) (TYPE%S. A&)))
 )))
 (axiom (forall ((x@ S.)) (!
    (= (S./S/a x@) (S./S/?a x@))
    :pattern ((S./S/a x@))
 )))
 (axiom (forall ((A& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%S. A&))
     (has_type (S./S/a (%Poly%S. x@)) A&)
    )
    :pattern ((S./S/a (%Poly%S. x@)) (has_type x@ (TYPE%S. A&)))
 )))
 (axiom (forall ((x@ S.)) (!
    (= (S./S/b x@) (S./S/?b x@))
    :pattern ((S./S/b x@))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
    :pattern ((Poly%tuple%0. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%tuple%0.)
     (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
    )
    :pattern ((has_type x@ TYPE%tuple%0.))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
    :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
 )))

 ;; Function-Decl crate::pervasive::invariants::Invariant::inv
 (declare-fun pervasive.invariants.Invariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariants::Invariant::namespace
 (declare-fun pervasive.invariants.Invariant.namespace.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::invariants::LocalInvariant::inv
 (declare-fun pervasive.invariants.LocalInvariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariants::LocalInvariant::namespace
 (declare-fun pervasive.invariants.LocalInvariant.namespace.? (Type Poly) Int)

 ;; Function-Axioms crate::pervasive::assert
 (declare-fun req%pervasive.assert. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (req%pervasive.assert. b@) b@)
    :pattern ((req%pervasive.assert. b@))
 )))
 (declare-fun ens%pervasive.assert. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (ens%pervasive.assert. b@) b@)
    :pattern ((ens%pervasive.assert. b@))
 )))

 ;; Function-Axioms crate::pervasive::assume
 (declare-fun ens%pervasive.assume. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (ens%pervasive.assume. b@) b@)
    :pattern ((ens%pervasive.assume. b@))
 )))

 ;; Function-Axioms crate::add1
 (declare-fun req%add1. (Int) Bool)
 (axiom (forall ((pre%a@ Int)) (!
    (= (req%add1. pre%a@) (axiom_location ("failed precondition") (< pre%a@ 10)))
    :pattern ((req%add1. pre%a@))
 )))
 (declare-fun ens%add1. (Int Int) Bool)
 (axiom (forall ((pre%a@ Int) (a@ Int)) (!
    (= (ens%add1. pre%a@ a@) (and
      (uInv 32 a@)
      (= a@ (uClip 32 (+ pre%a@ 1)))
    ))
    :pattern ((ens%add1. pre%a@ a@))
 )))

 ;; Function-Def crate::add1
 (check-valid
  (declare-var a@ Int)
  (axiom fuel_defaults)
  (axiom (uInv 32 a@))
  (axiom (< a@ 10))
  (block
   (snapshot snap%PRE)
   (assign a@ (uClip 32 (+ a@ 1)))
   (assert
    ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
    (= a@ (uClip 32 (+ (old snap%PRE a@) 1)))
 )))

 ;; Function-Def crate::foo
 (check-valid
  (declare-const s@ S.)
  (declare-const tmp%1@ Bool)
  (declare-const tmp%2@ Bool)
  (declare-const tmp%3@ Bool)
  (declare-var s$1@ S.)
  (axiom fuel_defaults)
  (axiom (has_type (Poly%S. s@) (TYPE%S. (UINT 32))))
  (block
   (assume
    (= s$1@ s@)
   )
   (block
    ; (assert
    ;  ("precondition not satisfied")
    ;  (req%add1. (%I (S./S/a (%Poly%S. (Poly%S. s$1@)))))
    ; )
    (snapshot snap%CALL)
    (havoc s$1@)
    (assume
     (= (S./S/b (old snap%CALL s$1@)) (S./S/b s$1@))
    )
    (assume
     (ens%add1. (%I (S./S/a (%Poly%S. (Poly%S. (old snap%CALL s$1@))))) (%I (S./S/a (%Poly%S.
         (Poly%S. s$1@)
    )))))
    (assume (has_type (Poly%S. s$1@) (TYPE%S. (UINT 32))))
   )
   ; (assume (= 6 (%I (I 6))))
   (assume
    (= tmp%1@ (= (%I (S./S/a (%Poly%S. (Poly%S. s$1@)))) 6))
   )
   (block
    (assume
     (ens%pervasive.assume. tmp%1@)
   ))
   (assert ("here") (= (%I (S./S/a (%Poly%S. (Poly%S. s$1@)))) 6))
   ; know (%I x) == 6
   ; don't know x == (I 6)
   ; (assume (has_type (S./S/a (%Poly%S. (Poly%S. s$1@))) (UINT 32)))
   ; (assert ("here") (= (I (%I (S./S/a (%Poly%S. (Poly%S. s$1@))))) (I 6)))
   ; (assert ("there") (= (S./S/a (%Poly%S. (Poly%S. s$1@))) (I 6)))
   (assume
    (= tmp%2@ (= (S./S/b (%Poly%S. (Poly%S. s$1@))) false))
   )
   (block
    (assume
     (ens%pervasive.assume. tmp%2@)
   ))
   (assume
    (= tmp%3@ (= s$1@ (S./S (I 6) (%B (B false)))))
   )
   (block
    (assert
     ("assertion failure C")
     (req%pervasive.assert. tmp%3@)
    )
    (assume
     (ens%pervasive.assert. tmp%3@)
 ))))

 ;; Function-Def crate::main
 (check-valid
  (axiom fuel_defaults)
  (block)
 )
(pop)
