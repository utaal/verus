(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :rlimit 30000000)

;; Prelude

;; AIR prelude

(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(axiom (=>
  fuel_defaults
  (forall ((id FuelId)) (!
    (= (fuel_bool id) (fuel_bool_default id))
    :pattern ((fuel_bool id))
    :qid
    prelude_fuel_defaults
    :skolemid
    skolem_prelude_fuel_defaults
))))
(declare-sort Char 0)
(declare-fun char%from_unicode (Int) Char)
(declare-fun char%to_unicode (Char) Int)
(declare-sort StrSlice 0)
(declare-fun str%strslice_is_ascii (StrSlice) Bool)
(declare-fun str%strslice_len (StrSlice) Int)
(declare-fun str%strslice_get_char (StrSlice Int) Char)
(declare-fun str%new_strlit (Int) StrSlice)
(declare-fun str%from_strlit (StrSlice) Int)
(declare-sort Poly 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun S (StrSlice) Poly)
(declare-fun %S (Poly) StrSlice)
(declare-fun C (Char) Poly)
(declare-fun %C (Poly) Char)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const STRSLICE Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (Fun) Fun)
(axiom (has_type (B true) BOOL))
(axiom (has_type (B false) BOOL))
(axiom (forall ((x Poly) (t Type)) (!
   (and
    (has_type (as_type x t) t)
    (=>
     (has_type x t)
     (= x (as_type x t))
   ))
   :pattern ((as_type x t))
   :qid
   prelude_as_type
   :skolemid
   skolem_prelude_as_type
)))
(axiom (forall ((x Fun)) (!
   (= (mk_fun x) x)
   :pattern ((mk_fun x))
   :qid
   prelude_mk_fun
   :skolemid
   skolem_prelude_mk_fun
)))
(axiom (forall ((x Bool)) (!
   (= x (%B (B x)))
   :pattern ((B x))
   :qid
   prelude_unbox_box_bool
   :skolemid
   skolem_prelude_unbox_box_bool
)))
(axiom (forall ((x Int)) (!
   (= x (%I (I x)))
   :pattern ((I x))
   :qid
   prelude_unbox_box_int
   :skolemid
   skolem_prelude_unbox_box_int
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x BOOL)
    (= x (B (%B x)))
   )
   :pattern ((has_type x BOOL))
   :qid
   prelude_box_unbox_bool
   :skolemid
   skolem_prelude_box_unbox_bool
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x INT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x INT))
   :qid
   prelude_box_unbox_int
   :skolemid
   skolem_prelude_box_unbox_int
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x NAT))
   :qid
   prelude_box_unbox_nat
   :skolemid
   skolem_prelude_box_unbox_nat
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (UINT bits)))
   :qid
   prelude_box_unbox_uint
   :skolemid
   skolem_prelude_box_unbox_uint
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (SINT bits)))
   :qid
   prelude_box_unbox_sint
   :skolemid
   skolem_prelude_box_unbox_sint
)))
(axiom (forall ((x Int)) (!
   (= (str%from_strlit (str%new_strlit x)) x)
   :pattern ((str%new_strlit x))
   :qid
   prelude_strlit_injective
   :skolemid
   skolem_prelude_strlit_injective
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x STRSLICE)
    (= x (S (%S x)))
   )
   :pattern ((has_type x STRSLICE))
   :qid
   prelude_box_unbox_strslice
   :skolemid
   skolem_prelude_box_unbox_strslice
)))
(axiom (forall ((x StrSlice)) (!
   (= x (%S (S x)))
   :pattern ((S x))
   :qid
   prelude_unbox_box_strslice
   :skolemid
   skolem_prelude_unbox_box_strslice
)))
(axiom (forall ((x StrSlice)) (!
   (has_type (S x) STRSLICE)
   :pattern ((has_type (S x) STRSLICE))
   :qid
   prelude_has_type_strslice
   :skolemid
   skolem_prelude_has_type_strslice
)))
(declare-const SZ Int)
(axiom (or
  (= SZ 32)
  (= SZ 64)
))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(axiom (= (uHi 8) 256))
(axiom (= (uHi 16) 65536))
(axiom (= (uHi 32) 4294967296))
(axiom (= (uHi 64) 18446744073709551616))
(axiom (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(axiom (= (iLo 8) (- 128)))
(axiom (= (iLo 16) (- 32768)))
(axiom (= (iLo 32) (- 2147483648)))
(axiom (= (iLo 64) (- 9223372036854775808)))
(axiom (= (iLo 128) (- 170141183460469231731687303715884105728)))
(axiom (= (iHi 8) 128))
(axiom (= (iHi 16) 32768))
(axiom (= (iHi 32) 2147483648))
(axiom (= (iHi 64) 9223372036854775808))
(axiom (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(axiom (forall ((i Int)) (!
   (and
    (<= 0 (nClip i))
    (=>
     (<= 0 i)
     (= i (nClip i))
   ))
   :pattern ((nClip i))
   :qid
   prelude_nat_clip
   :skolemid
   skolem_prelude_nat_clip
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= 0 (uClip bits i))
    (< (uClip bits i) (uHi bits))
    (=>
     (and
      (<= 0 i)
      (< i (uHi bits))
     )
     (= i (uClip bits i))
   ))
   :pattern ((uClip bits i))
   :qid
   prelude_u_clip
   :skolemid
   skolem_prelude_u_clip
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= (iLo bits) (iClip bits i))
    (< (iClip bits i) (iHi bits))
    (=>
     (and
      (<= (iLo bits) i)
      (< i (iHi bits))
     )
     (= i (iClip bits i))
   ))
   :pattern ((iClip bits i))
   :qid
   prelude_i_clip
   :skolemid
   skolem_prelude_i_clip
)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(axiom (forall ((bits Int) (i Int)) (!
   (= (uInv bits i) (and
     (<= 0 i)
     (< i (uHi bits))
   ))
   :pattern ((uInv bits i))
   :qid
   prelude_u_inv
   :skolemid
   skolem_prelude_u_inv
)))
(axiom (forall ((bits Int) (i Int)) (!
   (= (iInv bits i) (and
     (<= (iLo bits) i)
     (< i (iHi bits))
   ))
   :pattern ((iInv bits i))
   :qid
   prelude_i_inv
   :skolemid
   skolem_prelude_i_inv
)))
(axiom (forall ((x Int)) (!
   (has_type (I x) INT)
   :pattern ((has_type (I x) INT))
   :qid
   prelude_has_type_int
   :skolemid
   skolem_prelude_has_type_int
)))
(axiom (forall ((x Int)) (!
   (=>
    (<= 0 x)
    (has_type (I x) NAT)
   )
   :pattern ((has_type (I x) NAT))
   :qid
   prelude_has_type_nat
   :skolemid
   skolem_prelude_has_type_nat
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (uInv bits x)
    (has_type (I x) (UINT bits))
   )
   :pattern ((has_type (I x) (UINT bits)))
   :qid
   prelude_has_type_uint
   :skolemid
   skolem_prelude_has_type_uint
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (iInv bits x)
    (has_type (I x) (SINT bits))
   )
   :pattern ((has_type (I x) (SINT bits)))
   :qid
   prelude_has_type_sint
   :skolemid
   skolem_prelude_has_type_sint
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (<= 0 (%I x))
   )
   :pattern ((has_type x NAT))
   :qid
   prelude_unbox_int
   :skolemid
   skolem_prelude_unbox_int
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (uInv bits (%I x))
   )
   :pattern ((has_type x (UINT bits)))
   :qid
   prelude_unbox_uint
   :skolemid
   skolem_prelude_unbox_uint
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (iInv bits (%I x))
   )
   :pattern ((has_type x (SINT bits)))
   :qid
   prelude_unbox_sint
   :skolemid
   skolem_prelude_unbox_sint
)))
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(axiom (forall ((x Int) (y Int)) (!
   (= (Mul x y) (* x y))
   :pattern ((Mul x y))
   :qid
   prelude_mul
   :skolemid
   skolem_prelude_mul
)))
(axiom (forall ((x Int) (y Int)) (!
   (= (EucDiv x y) (div x y))
   :pattern ((EucDiv x y))
   :qid
   prelude_eucdiv
   :skolemid
   skolem_prelude_eucdiv
)))
(axiom (forall ((x Int) (y Int)) (!
   (= (EucMod x y) (mod x y))
   :pattern ((EucMod x y))
   :qid
   prelude_eucmod
   :skolemid
   skolem_prelude_eucmod
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x CHAR)
    (= x (C (%C x)))
   )
   :pattern ((has_type x CHAR))
   :qid
   prelude_box_unbox_char
   :skolemid
   skolem_prelude_box_unbox_char
)))
(axiom (forall ((x Char)) (!
   (= x (%C (C x)))
   :pattern ((C x))
   :qid
   prelude_unbox_box_char
   :skolemid
   skolem_prelude_unbox_box_char
)))
(axiom (forall ((x Char)) (!
   (has_type (C x) CHAR)
   :pattern ((has_type (C x) CHAR))
   :qid
   prelude_has_type_char
   :skolemid
   skolem_prelude_has_type_char
)))
(axiom (forall ((x Int)) (!
   (= (char%to_unicode (char%from_unicode x)) x)
   :pattern ((char%from_unicode x))
   :qid
   prelude_char_injective
   :skolemid
   skolem_prelude_char_injective
)))
(axiom (forall ((c Char)) (!
   (and
    (<= 0 (char%to_unicode c))
    (< (char%to_unicode c) (uHi 32))
   )
   :pattern ((char%to_unicode c))
   :qid
   prelude_to_unicode_bounds
   :skolemid
   skolem_prelude_to_unicode_bounds
)))
(declare-fun check_decrease_int.? (Int Int Bool) Bool)
(axiom (forall ((cur Int) (prev Int) (otherwise Bool)) (!
   (= (check_decrease_int.? cur prev otherwise) (or
     (and
      (<= 0 cur)
      (< cur prev)
     )
     (and
      (= cur prev)
      otherwise
   )))
   :pattern ((check_decrease_int.? cur prev otherwise))
   :qid
   prelude_check_decreases
   :skolemid
   skolem_prelude_check_decreases
)))
(declare-fun height.? (Poly) Int)
(axiom (forall ((x Poly)) (!
   (<= 0 (height.? x))
   :pattern ((height.? x))
   :qid
   prelude_height
   :skolemid
   skolem_prelude_height
)))
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)

;; MODULE ''

;; Fuel
(declare-const fuel%max. FuelId)
(declare-const fuel%Node.height. FuelId)
(axiom (distinct fuel%max. fuel%Node.height.))

;; Datatypes
(declare-datatypes ((pervasive.option.Option. 0) (Node. 0) (tuple%0. 0)) (((pervasive.option.Option./None)
   (pervasive.option.Option./Some (pervasive.option.Option./Some/?_0 Poly))
  ) ((Node./Node (Node./Node/?left pervasive.option.Option.) (Node./Node/?right pervasive.option.Option.)
    (Node./Node/?value Poly)
   )
  ) ((tuple%0./tuple%0))
))
(declare-fun pervasive.option.Option./Some/_0 (pervasive.option.Option.) Poly)
(declare-fun Node./Node/left (Node.) pervasive.option.Option.)
(declare-fun Node./Node/right (Node.) pervasive.option.Option.)
(declare-fun Node./Node/value (Node.) Poly)
(declare-fun TYPE%pervasive.option.Option. (Type) Type)
(declare-fun TYPE%pervasive.invariant.AtomicInvariant. (Type) Type)
(declare-fun TYPE%pervasive.invariant.LocalInvariant. (Type) Type)
(declare-fun TYPE%Node. (Type) Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun Poly%pervasive.option.Option. (pervasive.option.Option.) Poly)
(declare-fun %Poly%pervasive.option.Option. (Poly) pervasive.option.Option.)
(declare-fun Poly%Node. (Node.) Poly)
(declare-fun %Poly%Node. (Poly) Node.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(axiom (forall ((x@ pervasive.option.Option.)) (!
   (= x@ (%Poly%pervasive.option.Option. (Poly%pervasive.option.Option. x@)))
   :pattern ((Poly%pervasive.option.Option. x@))
   :qid
   internal_crate__pervasive__option__Option_box_axiom_definition
   :skolemid
   skolem_internal_crate__pervasive__option__Option_box_axiom_definition
)))
(axiom (forall ((A& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%pervasive.option.Option. A&))
    (= x@ (Poly%pervasive.option.Option. (%Poly%pervasive.option.Option. x@)))
   )
   :pattern ((has_type x@ (TYPE%pervasive.option.Option. A&)))
   :qid
   internal_crate__pervasive__option__Option_unbox_axiom_definition
   :skolemid
   skolem_internal_crate__pervasive__option__Option_unbox_axiom_definition
)))
(axiom (forall ((A& Type)) (!
   (has_type (Poly%pervasive.option.Option. (pervasive.option.Option./None)) (TYPE%pervasive.option.Option.
     A&
   ))
   :pattern ((has_type (Poly%pervasive.option.Option. (pervasive.option.Option./None))
     (TYPE%pervasive.option.Option. A&)
   ))
   :qid
   internal_pervasive.option.Option./None_constructor_definition
   :skolemid
   skolem_internal_pervasive.option.Option./None_constructor_definition
)))
(axiom (forall ((A& Type) (_0@ Poly)) (!
   (=>
    (has_type _0@ A&)
    (has_type (Poly%pervasive.option.Option. (pervasive.option.Option./Some _0@)) (TYPE%pervasive.option.Option.
      A&
   )))
   :pattern ((has_type (Poly%pervasive.option.Option. (pervasive.option.Option./Some _0@))
     (TYPE%pervasive.option.Option. A&)
   ))
   :qid
   internal_pervasive.option.Option./Some_constructor_definition
   :skolemid
   skolem_internal_pervasive.option.Option./Some_constructor_definition
)))
(axiom (forall ((x@ pervasive.option.Option.)) (!
   (= (pervasive.option.Option./Some/_0 x@) (pervasive.option.Option./Some/?_0 x@))
   :pattern ((pervasive.option.Option./Some/_0 x@))
   :qid
   internal_pervasive.option.Option./Some/_0_accessor_definition
   :skolemid
   skolem_internal_pervasive.option.Option./Some/_0_accessor_definition
)))
(axiom (forall ((A& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%pervasive.option.Option. A&))
    (has_type (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option. x@)) A&)
   )
   :pattern ((pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option. x@)) (
     has_type x@ (TYPE%pervasive.option.Option. A&)
   ))
   :qid
   internal_pervasive.option.Option./Some/_0_invariant_definition
   :skolemid
   skolem_internal_pervasive.option.Option./Some/_0_invariant_definition
)))
(axiom (forall ((x@ Node.)) (!
   (= x@ (%Poly%Node. (Poly%Node. x@)))
   :pattern ((Poly%Node. x@))
   :qid
   internal_crate__Node_box_axiom_definition
   :skolemid
   skolem_internal_crate__Node_box_axiom_definition
)))
(axiom (forall ((V& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%Node. V&))
    (= x@ (Poly%Node. (%Poly%Node. x@)))
   )
   :pattern ((has_type x@ (TYPE%Node. V&)))
   :qid
   internal_crate__Node_unbox_axiom_definition
   :skolemid
   skolem_internal_crate__Node_unbox_axiom_definition
)))
(axiom (forall ((V& Type) (left@ pervasive.option.Option.) (right@ pervasive.option.Option.)
   (value@ Poly)
  ) (!
   (=>
    (and
     (has_type (Poly%pervasive.option.Option. left@) (TYPE%pervasive.option.Option. (TYPE%Node.
        V&
     )))
     (has_type (Poly%pervasive.option.Option. right@) (TYPE%pervasive.option.Option. (TYPE%Node.
        V&
     )))
     (has_type value@ V&)
    )
    (has_type (Poly%Node. (Node./Node left@ right@ value@)) (TYPE%Node. V&))
   )
   :pattern ((has_type (Poly%Node. (Node./Node left@ right@ value@)) (TYPE%Node. V&)))
   :qid
   internal_Node./Node_constructor_definition
   :skolemid
   skolem_internal_Node./Node_constructor_definition
)))
(axiom (forall ((x@ Node.)) (!
   (= (Node./Node/left x@) (Node./Node/?left x@))
   :pattern ((Node./Node/left x@))
   :qid
   internal_Node./Node/left_accessor_definition
   :skolemid
   skolem_internal_Node./Node/left_accessor_definition
)))
(axiom (forall ((V& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%Node. V&))
    (has_type (Poly%pervasive.option.Option. (Node./Node/left (%Poly%Node. x@))) (TYPE%pervasive.option.Option.
      (TYPE%Node. V&)
   )))
   :pattern ((Node./Node/left (%Poly%Node. x@)) (has_type x@ (TYPE%Node. V&)))
   :qid
   internal_Node./Node/left_invariant_definition
   :skolemid
   skolem_internal_Node./Node/left_invariant_definition
)))
(axiom (forall ((x@ Node.)) (!
   (= (Node./Node/right x@) (Node./Node/?right x@))
   :pattern ((Node./Node/right x@))
   :qid
   internal_Node./Node/right_accessor_definition
   :skolemid
   skolem_internal_Node./Node/right_accessor_definition
)))
(axiom (forall ((V& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%Node. V&))
    (has_type (Poly%pervasive.option.Option. (Node./Node/right (%Poly%Node. x@))) (TYPE%pervasive.option.Option.
      (TYPE%Node. V&)
   )))
   :pattern ((Node./Node/right (%Poly%Node. x@)) (has_type x@ (TYPE%Node. V&)))
   :qid
   internal_Node./Node/right_invariant_definition
   :skolemid
   skolem_internal_Node./Node/right_invariant_definition
)))
(axiom (forall ((x@ Node.)) (!
   (= (Node./Node/value x@) (Node./Node/?value x@))
   :pattern ((Node./Node/value x@))
   :qid
   internal_Node./Node/value_accessor_definition
   :skolemid
   skolem_internal_Node./Node/value_accessor_definition
)))
(axiom (forall ((V& Type) (x@ Poly)) (!
   (=>
    (has_type x@ (TYPE%Node. V&))
    (has_type (Node./Node/value (%Poly%Node. x@)) V&)
   )
   :pattern ((Node./Node/value (%Poly%Node. x@)) (has_type x@ (TYPE%Node. V&)))
   :qid
   internal_Node./Node/value_invariant_definition
   :skolemid
   skolem_internal_Node./Node/value_invariant_definition
)))
(axiom (forall ((x pervasive.option.Option.)) (!
   (= (height.? (pervasive.option.Option./Some/_0 x)) (height.? (Poly%pervasive.option.Option. x)))
   :pattern ((height.? (pervasive.option.Option./Some/_0 x)))
   :qid
   prelude_datatype_height
   :skolemid
   skolem_prelude_datatype_height
)))
(axiom (forall ((x Node.)) (!
   (< (height.? (Poly%pervasive.option.Option. (Node./Node/left x))) (height.? (Poly%Node.
      x
   )))
   :pattern ((height.? (Poly%pervasive.option.Option. (Node./Node/left x))))
   :qid
   prelude_datatype_height
   :skolemid
   skolem_prelude_datatype_height
)))
(axiom (forall ((x Node.)) (!
   (< (height.? (Poly%pervasive.option.Option. (Node./Node/right x))) (height.? (Poly%Node.
      x
   )))
   :pattern ((height.? (Poly%pervasive.option.Option. (Node./Node/right x))))
   :qid
   prelude_datatype_height
   :skolemid
   skolem_prelude_datatype_height
)))
(axiom (forall ((x@ tuple%0.)) (!
   (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
   :pattern ((Poly%tuple%0. x@))
   :qid
   internal_crate__tuple__0_box_axiom_definition
   :skolemid
   skolem_internal_crate__tuple__0_box_axiom_definition
)))
(axiom (forall ((x@ Poly)) (!
   (=>
    (has_type x@ TYPE%tuple%0.)
    (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
   )
   :pattern ((has_type x@ TYPE%tuple%0.))
   :qid
   internal_crate__tuple__0_unbox_axiom_definition
   :skolemid
   skolem_internal_crate__tuple__0_unbox_axiom_definition
)))
(axiom (forall ((x@ tuple%0.)) (!
   (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
   :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
   :qid
   internal_crate__tuple__0_has_type_always_definition
   :skolemid
   skolem_internal_crate__tuple__0_has_type_always_definition
)))

;; Function-Decl crate::pervasive::invariant::AtomicInvariant::inv
(declare-fun pervasive.invariant.AtomicInvariant.inv.? (Type Poly Poly) Bool)

;; Function-Decl crate::pervasive::invariant::AtomicInvariant::namespace
(declare-fun pervasive.invariant.AtomicInvariant.namespace.? (Type Poly) Int)

;; Function-Decl crate::pervasive::invariant::LocalInvariant::inv
(declare-fun pervasive.invariant.LocalInvariant.inv.? (Type Poly Poly) Bool)

;; Function-Decl crate::pervasive::invariant::LocalInvariant::namespace
(declare-fun pervasive.invariant.LocalInvariant.namespace.? (Type Poly) Int)

;; Function-Decl crate::max
(declare-fun max.? (Poly Poly) Int)

;; Function-Decl crate::Node::height
(declare-fun Node.height.? (Type Poly) Int)
(declare-fun Node.rec%height.? (Type Poly Fuel) Int)

;; Function-Axioms crate::max
(axiom (fuel_bool_default fuel%max.))
(axiom (=>
  (fuel_bool fuel%max.)
  (forall ((a~2@ Poly) (b~4@ Poly)) (!
    (= (max.? a~2@ b~4@) (%I (ite
       (>= (%I a~2@) (%I b~4@))
       a~2@
       b~4@
    )))
    :pattern ((max.? a~2@ b~4@))
    :qid
    internal_max.?_definition
    :skolemid
    skolem_internal_max.?_definition
))))
(axiom (forall ((a~2@ Poly) (b~4@ Poly)) (!
   (=>
    (and
     (has_type a~2@ NAT)
     (has_type b~4@ NAT)
    )
    (<= 0 (max.? a~2@ b~4@))
   )
   :pattern ((max.? a~2@ b~4@))
   :qid
   internal_max.?_pre_post_definition
   :skolemid
   skolem_internal_max.?_pre_post_definition
)))

;; Function-Termination crate::Node::height
(check-valid
 (declare-const V& Type)
 (declare-const self~2@ Poly)
 (declare-const decrease%init0@ Int)
 (axiom fuel_defaults)
 (axiom (has_type self~2@ (TYPE%Node. V&)))
 (block
  (assume
   (= decrease%init0@ (height.? (Poly%Node. (%Poly%Node. self~2@))))
  )
  (assert
   ("could not prove termination")
   (and
    (let
     ((tmp%%1$ (Node./Node/left (%Poly%Node. self~2@))))
     (=>
      (is-pervasive.option.Option./Some tmp%%1$)
      (let
       ((l~12$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
            (Poly%pervasive.option.Option. tmp%%1$)
       )))))
       (check_decrease_int.? (height.? (Poly%Node. (let
           ((self~2!$ (Poly%Node. l~12$)))
           (%Poly%Node. self~2!$)
         ))
        ) decrease%init0@ false
    ))))
    (let
     ((tmp%%2$ (Node./Node/right (%Poly%Node. self~2@))))
     (=>
      (is-pervasive.option.Option./Some tmp%%2$)
      (let
       ((r~30$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
            (Poly%pervasive.option.Option. tmp%%2$)
       )))))
       (check_decrease_int.? (height.? (Poly%Node. (let
           ((self~2!$ (Poly%Node. r~30$)))
           (%Poly%Node. self~2!$)
         ))
        ) decrease%init0@ false
))))))))

;; Function-Decl-Check-Recommends crate::Node::height
(check-valid
 (declare-const V& Type)
 (declare-const %return@ Int)
 (declare-const self~2@ Poly)
 (axiom fuel_defaults)
 (axiom (has_type self~2@ (TYPE%Node. V&)))
 (assume
  (= %return@ (max.? (I (let
      ((tmp%%1$ (Node./Node/left (%Poly%Node. self~2@))))
      (ite
       (is-pervasive.option.Option./Some tmp%%1$)
       (let
        ((l~12$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
             (Poly%pervasive.option.Option. tmp%%1$)
        )))))
        (Node.height.? V& (Poly%Node. l~12$))
       )
       0
     ))
    ) (I (let
      ((tmp%%2$ (Node./Node/right (%Poly%Node. self~2@))))
      (ite
       (is-pervasive.option.Option./Some tmp%%2$)
       (let
        ((r~30$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
             (Poly%pervasive.option.Option. tmp%%2$)
        )))))
        (Node.height.? V& (Poly%Node. r~30$))
       )
       0
)))))))

;; Function-Axioms crate::Node::height
(axiom (fuel_bool_default fuel%Node.height.))
(declare-const fuel_nat%Node.height. Fuel)
(axiom (forall ((V& Type) (self~2@ Poly) (fuel%@ Fuel)) (!
   (= (Node.rec%height.? V& self~2@ fuel%@) (Node.rec%height.? V& self~2@ zero))
   :pattern ((Node.rec%height.? V& self~2@ fuel%@))
   :qid
   internal_Node.height._fuel_to_zero_definition
   :skolemid
   skolem_internal_Node.height._fuel_to_zero_definition
)))
(axiom (forall ((V& Type) (self~2@ Poly) (fuel%@ Fuel)) (!
   (= (Node.rec%height.? V& self~2@ (succ fuel%@)) (max.? (I (let
       ((tmp%%1$ (Node./Node/left (%Poly%Node. self~2@))))
       (ite
        (is-pervasive.option.Option./Some tmp%%1$)
        (let
         ((l~12$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
              (Poly%pervasive.option.Option. tmp%%1$)
         )))))
         (Node.rec%height.? V& (Poly%Node. l~12$) fuel%@)
        )
        0
      ))
     ) (I (let
       ((tmp%%2$ (Node./Node/right (%Poly%Node. self~2@))))
       (ite
        (is-pervasive.option.Option./Some tmp%%2$)
        (let
         ((r~30$ (%Poly%Node. (pervasive.option.Option./Some/_0 (%Poly%pervasive.option.Option.
              (Poly%pervasive.option.Option. tmp%%2$)
         )))))
         (Node.rec%height.? V& (Poly%Node. r~30$) fuel%@)
        )
        0
   )))))
   :pattern ((Node.rec%height.? V& self~2@ (succ fuel%@)))
   :qid
   internal_Node.height._fuel_to_body_definition
   :skolemid
   skolem_internal_Node.height._fuel_to_body_definition
)))
(axiom (=>
  (fuel_bool fuel%Node.height.)
  (forall ((V& Type) (self~2@ Poly)) (!
    (= (Node.height.? V& self~2@) (Node.rec%height.? V& self~2@ (succ fuel_nat%Node.height.)))
    :pattern ((Node.height.? V& self~2@))
    :qid
    internal_Node.height.?_definition
    :skolemid
    skolem_internal_Node.height.?_definition
))))
(axiom (forall ((V& Type) (self~2@ Poly)) (!
   (=>
    (has_type self~2@ (TYPE%Node. V&))
    (<= 0 (Node.height.? V& self~2@))
   )
   :pattern ((Node.height.? V& self~2@))
   :qid
   internal_Node.height.?_pre_post_definition
   :skolemid
   skolem_internal_Node.height.?_pre_post_definition
)))

;; Function-Def crate::main
(check-valid
 (declare-const no%param@ Int)
 (axiom fuel_defaults)
 (block)
)
